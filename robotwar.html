<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Retro Battle: 1vs1 Manual</title>
    <style>
        body { margin: 0; background: #050505; overflow: hidden; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; color: #0F0; font-family: 'Courier New', monospace; }
        canvas { border: 4px solid #222; background: #000; cursor: pointer; }
        .ui { font-size: 24px; margin-bottom: 10px; text-shadow: 2px 2px #030; }
        .instructions { font-size: 14px; color: #AAA; margin-top: 10px; text-align: center; line-height: 1.5; }
        .keys { color: #666; font-size: 12px; }
    </style>
</head>
<body>

<div class="ui">P1: <span id="p1">0</span> | P2: <span id="p2">0</span></div>
<canvas id="gameCanvas"></canvas>
<div class="instructions">
    PRIMEIRO A 10 PONTOS VENCE<br>
    <span class="keys">P1: [W][S] Move | [ESPAÇO] Atira</span><br>
    <span class="keys">P2: [SETAS] Move | [ENTER] Atira</span>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 600; canvas.height = 350;

    let score1 = 0, score2 = 0;
    let gameOver = false;
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const keys = {};
    
    // Captura teclas (usando o.key para detectar 'Enter' e ' ')
    window.onkeydown = (e) => keys[e.key.toLowerCase()] = true;
    window.onkeyup = (e) => keys[e.key.toLowerCase()] = false;

    function snd(f, t, d, v) {
        if(audioCtx.state !== 'running') return;
        const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
        o.type = t; o.frequency.setValueAtTime(f, audioCtx.currentTime);
        g.gain.setValueAtTime(v, audioCtx.currentTime);
        g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + d);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + d);
    }

    class Tank {
        constructor(x, y, color, dir, upKey, downKey, shootKey) {
            this.x = x; this.y = y; this.color = color; this.dir = dir;
            this.upKey = upKey; this.downKey = downKey; this.shootKey = shootKey;
            this.alive = true; this.lastShot = 0;
            this.powerTimer = 0;
        }
        
        update() {
            if (!this.alive || gameOver) return;
            
            // Movimentação
            if (keys[this.upKey] && this.y > 10) this.y -= 4;
            if (keys[this.downKey] && this.y < canvas.height - 30) this.y += 4;

            // Tiro Manual com Cooldown (espera entre tiros)
            let cooldown = this.powerTimer > 0 ? 200 : 600; // Powerup diminui o tempo de espera
            if (keys[this.shootKey] && Date.now() - this.lastShot > cooldown) {
                bullets.push({
                    x: this.x + (this.dir > 0 ? 35 : -5), 
                    y: this.y + 7, 
                    dx: this.dir * 7, 
                    c: this.color
                });
                snd(this.dir > 0 ? 500 : 400, 'square', 0.1, 0.04);
                this.lastShot = Date.now();
            }

            if(this.powerTimer > 0) this.powerTimer--;
        }

        draw() {
            if (!this.alive) return;
            ctx.fillStyle = this.powerTimer > 0 ? '#FFF' : this.color;
            ctx.fillRect(this.x, this.y, 30, 20);
            ctx.fillRect(this.x + (this.dir > 0 ? 25 : -10), this.y + 7, 15, 6);
        }
    }

    // P1: 'w', 's', ' ' (espaço) | P2: 'arrowup', 'arrowdown', 'enter'
    let tanks = [
        new Tank(30, 150, '#0FF', 1, 'w', 's', ' '), 
        new Tank(540, 150, '#F0F', -1, 'arrowup', 'arrowdown', 'enter')
    ];
    
    let bullets = [], particles = [], powerUp = null;
    const walls = [{x: 285, y: 40, w: 30, h: 90}, {x: 285, y: 220, w: 30, h: 90}];

    function resetGame() {
        score1 = 0; score2 = 0;
        document.getElementById('p1').innerText = 0;
        document.getElementById('p2').innerText = 0;
        gameOver = false;
        bullets = []; particles = []; powerUp = null;
        tanks.forEach(t => { t.alive = true; t.powerTimer = 0; });
        animate();
    }

    function animate() {
        if(gameOver) return;

        ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Spawn de PowerUp
        if (!powerUp && Math.random() < 0.003) powerUp = {x: 290, y: 165, w: 20, h: 20};
        if(powerUp) {
            ctx.fillStyle = '#FF0'; ctx.fillRect(powerUp.x, powerUp.y, 20, 20);
        }

        tanks.forEach(t => { t.update(); t.draw(); });
        ctx.fillStyle = '#333';
        walls.forEach(w => ctx.fillRect(w.x, w.y, w.w, w.h));

        // Lógica das Balas
        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i]; b.x += b.dx;
            ctx.fillStyle = "#FFF"; ctx.fillRect(b.x, b.y, 10, 3);

            // Colisão PowerUp
            if(powerUp && b.x > powerUp.x && b.x < powerUp.x + 20 && b.y > powerUp.y && b.y < powerUp.y + 20) {
                tanks.forEach(t => { if(t.color === b.c) t.powerTimer = 400; });
                powerUp = null; b.hit = true; snd(800, 'sine', 0.2, 0.1);
            }

            // Colisão Paredes
            walls.forEach(w => { if(b.x > w.x && b.x < w.x+w.w && b.y > w.y && b.y < w.y+w.h) b.hit = true; });

            // Colisão Tanques
            tanks.forEach((t, idx) => {
                if (t.alive && b.x > t.x && b.x < t.x + 30 && b.y > t.y && b.y < t.y + 20) {
                    t.alive = false; b.hit = true;
                    if(idx === 0) score2++; else score1++;
                    document.getElementById('p1').innerText = score1;
                    document.getElementById('p2').innerText = score2;
                    snd(80, 'sawtooth', 0.5, 0.2);
                    for(let j=0; j<40; j++) particles.push({x: t.x+15, y: t.y+10, vx: (Math.random()-0.5)*15, vy: (Math.random()-0.5)*15, l: 1, c: t.color});
                    
                    if(score1 >= 10 || score2 >= 10) {
                        gameOver = true;
                        setTimeout(drawGameOver, 100);
                    } else {
                        setTimeout(() => t.alive = true, 1500);
                    }
                }
            });
            if (b.x < 0 || b.x > canvas.width || b.hit) bullets.splice(i, 1);
        }

        // Partículas de Explosão
        particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.l -= 0.04;
            ctx.fillStyle = Math.random() > 0.4 ? p.c : "#FFF";
            ctx.fillRect(p.x, p.y, 4, 4);
            if(p.l <= 0) particles.splice(i, 1);
        });

        requestAnimationFrame(animate);
    }

    function drawGameOver() {
        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#0F0";
        ctx.textAlign = "center";
        ctx.font = "40px 'Courier New'";
        ctx.fillText("FIM DE JOGO", canvas.width/2, canvas.height/2 - 20);
        ctx.font = "20px 'Courier New'";
        ctx.fillText(score1 >= 10 ? "JOGADOR 1 VENCEU!" : "JOGADOR 2 VENCEU!", canvas.width/2, canvas.height/2 + 20);
        ctx.fillStyle = "#FFF";
        ctx.fillText("CLIQUE PARA REINICIAR", canvas.width/2, canvas.height/2 + 60);
    }

    canvas.addEventListener('mousedown', () => {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        if (gameOver) resetGame();
    });

    animate();
</script>
</body>
</html>

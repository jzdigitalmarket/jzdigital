<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Retro Battle: Gamepad Edition</title>
    <style>
        body { 
            margin: 0; 
            background: #000; 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            color: #0F0; 
            font-family: 'Courier New', monospace; 
            position: relative;
        }

        #bgCanvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }

        #game-container {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #gameCanvas { 
            border: 4px solid #222; 
            background: #000; 
            cursor: pointer; 
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }

        .ui { font-size: 24px; margin-bottom: 10px; text-shadow: 2px 2px #030; pointer-events: none; }
        .timer { color: #F00; font-weight: bold; }
        .instructions { font-size: 14px; color: #AAA; margin-top: 10px; text-align: center; line-height: 1.5; pointer-events: none; }
        .keys { color: #666; font-size: 12px; }
    </style>
</head>
<body>

<canvas id="bgCanvas"></canvas>

<div id="game-container">
    <div class="ui">
        P1: <span id="p1">0</span> | 
        <span class="timer">TEMPO: <span id="timer">60</span>s</span> | 
        P2: <span id="p2">0</span>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div class="instructions">
        MAIOR PONTUADOR EM 60 SEGUNDOS VENCE<br>
        <span class="keys">P1: [W][S] | P2: [Setas]</span>
        <div id="gp-info" style="color: #555; font-size: 10px;">Aperte um botão no controle.</div>
    </div>
</div>

<script>
    // --- FUNDO GEOMÉTRICO ---
    const bgCanvas = document.getElementById('bgCanvas');
    const bgCtx = bgCanvas.getContext('2d');
    let shapes = [];

    function resizeBg() { bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight; }
    window.addEventListener('resize', resizeBg);
    resizeBg();

    class GeomShape {
        constructor() { this.init(); }
        init() {
            this.x = Math.random() * bgCanvas.width;
            this.y = Math.random() * bgCanvas.height;
            this.size = Math.random() * 30 + 10;
            this.vx = (Math.random() - 0.5) * 0.5;
            this.vy = (Math.random() - 0.5) * 0.5;
            this.rot = Math.random() * Math.PI * 2;
            this.vr = (Math.random() - 0.5) * 0.01;
            this.type = Math.random() > 0.5 ? 'rect' : 'tri';
            const alpha = Math.random() * 0.1 + 0.02;
            this.color = `rgba(0, 255, 0, ${alpha})`;
        }
        update() {
            this.x += this.vx; this.y += this.vy; this.rot += this.vr;
            if (this.x < -this.size) this.x = bgCanvas.width + this.size;
            if (this.x > bgCanvas.width + this.size) this.x = -this.size;
        }
        draw() {
            bgCtx.save(); bgCtx.translate(this.x, this.y); bgCtx.rotate(this.rot);
            bgCtx.strokeStyle = this.color; bgCtx.beginPath();
            if (this.type === 'rect') bgCtx.rect(-this.size/2, -this.size/2, this.size, this.size);
            else { bgCtx.moveTo(0, -this.size/2); bgCtx.lineTo(this.size/2, this.size/2); bgCtx.lineTo(-this.size/2, this.size/2); bgCtx.closePath(); }
            bgCtx.stroke(); bgCtx.restore();
        }
    }
    for(let i = 0; i < 50; i++) shapes.push(new GeomShape());
    function animateBg() {
        bgCtx.fillStyle = 'rgba(0, 0, 0, 0.05)'; bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
        shapes.forEach(s => { s.update(); s.draw(); });
        requestAnimationFrame(animateBg);
    }
    animateBg();

    // --- LÓGICA DO JOGO ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 600; canvas.height = 350;

    let score1 = 0, score2 = 0, gameOver = false, tempoLimite = 60, tempoInicial = Date.now();
    const ironias = ["Parabéns! São igualmente ruins.", "O vencedor foi o tédio.", "Empate técnico: os dois perderam meu respeito."];
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const keys = {};

    window.onkeydown = (e) => keys[e.key.toLowerCase()] = true;
    window.onkeyup = (e) => keys[e.key.toLowerCase()] = false;

    // Função para falar com o Python no Vercel
    async function enviarPontuacao(vencedor, pontos) {
        console.log("Enviando dados para o Python...");
        try {
            const resposta = await fetch('/api/save-score', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ nome: vencedor, pontos: pontos })
            });
            const top5 = await resposta.json();
            console.log("Ranking:", top5);
        } catch (e) { console.error("Erro na API:", e); }
    }

    function snd(f, t, d, v) {
        if(audioCtx.state !== 'running') return;
        const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
        o.type = t; o.frequency.setValueAtTime(f, audioCtx.currentTime);
        g.gain.setValueAtTime(v, audioCtx.currentTime);
        g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + d);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + d);
    }

    class Tank {
        constructor(x, y, color, dir, upKey, downKey, shootKey, gpIndex) {
            this.x = x; this.y = y; this.color = color; this.dir = dir;
            this.upKey = upKey; this.downKey = downKey; this.shootKey = shootKey;
            this.gpIndex = gpIndex; this.alive = true; this.lastShot = 0; this.powerTimer = 0;
        }
        update() {
            if (!this.alive || gameOver) return;
            let moveUp = keys[this.upKey], moveDown = keys[this.downKey], shoot = keys[this.shootKey];
            const gp = navigator.getGamepads()[this.gpIndex];
            if (gp) {
                if (gp.axes[1] < -0.5 || gp.buttons[12].pressed) moveUp = true;
                if (gp.axes[1] > 0.5 || gp.buttons[13].pressed) moveDown = true;
                if (gp.buttons[0].pressed) shoot = true;
            }
            if (moveUp && this.y > 10) this.y -= 4;
            if (moveDown && this.y < canvas.height - 30) this.y += 4;
            let cd = this.powerTimer > 0 ? 200 : 600;
            if (shoot && Date.now() - this.lastShot > cd) {
                bullets.push({x: this.x + (this.dir > 0 ? 35 : -5), y: this.y + 7, dx: this.dir * 7, c: this.color});
                snd(400, 'square', 0.1, 0.04); this.lastShot = Date.now();
            }
            if(this.powerTimer > 0) this.powerTimer--;
        }
        draw() { if (this.alive) { ctx.fillStyle = this.powerTimer > 0 ? '#FFF' : this.color; ctx.fillRect(this.x, this.y, 30, 20); } }
    }

    let tanks = [new Tank(30, 150, '#0FF', 1, 'w', 's', ' ', 0), new Tank(540, 150, '#F0F', -1, 'arrowup', 'arrowdown', 'enter', 1)];
    let bullets = [], particles = [], powerUp = null;
    const walls = [{x: 285, y: 20, w: 30, h: 80, dy: 2}, {x: 285, y: 250, w: 30, h: 80, dy: -2}];

    function animateGame() {
        if(gameOver) return;
        let tempoRestante = Math.max(0, tempoLimite - Math.floor((Date.now() - tempoInicial) / 1000));
        document.getElementById('timer').innerText = tempoRestante;

        if (tempoRestante <= 0) {
            gameOver = true;
            finalizarPartida();
            return;
        }

        ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        tanks.forEach(t => { t.update(); t.draw(); });
        
        // Lógica de balas e colisões simplificada
        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i]; b.x += b.dx;
            ctx.fillStyle = "#FFF"; ctx.fillRect(b.x, b.y, 10, 3);
            tanks.forEach((t, idx) => {
                if (t.alive && b.x > t.x && b.x < t.x + 30 && b.y > t.y && b.y < t.y + 20) {
                    t.alive = false; b.hit = true;
                    if(idx === 0) score2++; else score1++;
                    document.getElementById('p1').innerText = score1;
                    document.getElementById('p2').innerText = score2;
                    setTimeout(() => { if(!gameOver) t.alive = true }, 1500);
                }
            });
            if (b.x < 0 || b.x > canvas.width || b.hit) bullets.splice(i, 1);
        }
        requestAnimationFrame(animateGame);
    }

    function finalizarPartida() {
        // Desenha tela final
        ctx.fillStyle = "rgba(0,0,0,0.85)"; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#0F0"; ctx.textAlign = "center"; ctx.font = "40px 'Courier New'";
        ctx.fillText("FIM DE TEMPO", canvas.width/2, canvas.height/2 - 40);

        let finalMsg = "";
        if (score1 > score2) {
            finalMsg = "JOGADOR 1 VENCEU!";
            enviarPontuacao("Jogador 1", score1);
        } else if (score2 > score1) {
            finalMsg = "JOGADOR 2 VENCEU!";
            enviarPontuacao("Jogador 2", score2);
        } else {
            finalMsg = ironias[Math.floor(Math.random() * ironias.length)];
            ctx.fillStyle = "#FF0";
        }
        ctx.font = "20px 'Courier New'";
        ctx.fillText(finalMsg, canvas.width/2, canvas.height/2 + 10);
        ctx.fillStyle = "#FFF"; ctx.fillText("CLIQUE PARA REINICIAR", canvas.width/2, canvas.height/2 + 70);
    }

    function resetGame() {
        score1 = 0; score2 = 0; gameOver = false; tempoInicial = Date.now();
        document.getElementById('p1').innerText = 0; document.getElementById('p2').innerText = 0;
        tanks.forEach(t => t.alive = true); bullets = [];
        animateGame();
    }

    canvas.addEventListener('mousedown', () => {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        if (gameOver) resetGame();
    });

    animateGame();
</script>
</body>
</html>
